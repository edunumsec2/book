
# Introduction

## Quoi ?

Pour résoudre un problème, il faut commencer par le décomposer en sous&#8209;problèmes. Pour chaque sous&#8209;problème à résoudre, on décrit les opérations à réaliser sous la forme d’un {glo}`algo|algorithme`. Il existe une multitude d’{glo}`algo|algorithmes` pour résoudre un problème, mais ils ne se valent pas tous. 

L’**<span style="color:rgb(89, 51, 209)">algorithmique</span>** étudie les propriétés de ces {glo}`algo|algorithmes`. Cette analyse est nécessaire pour nous aider à décider quel {glo}`algo|algorithme` utiliser. On se propose à présent de passer en revue quelques propriétés importantes des {glo}`algo|algorithmes`. 



```{figure} media/Shadok.jpeg
---
alt: devise shadok
width: 300px

```

## Pourquoi ?

Si tous les chemins mènent à Rome, on ne peut en emprunter qu'un. Lorsqu'on est face à plusieurs chemins pour arriver au même résultat, il est important de choisir le chemin le plus optimal. 

Vous avez déjà rencontré plusieurs algorithmes pour arriver jusqu'ici. Encore plus fort, vous avez rencontré plusieurs algorithmes pour résoudre un même problème, ce qui nous met face à un dilemme : quelle algorithme choisir ? Et y a&#8209;t&#8209;il une solution à tout problème ?

## Comment ?

Dans un premier temps nous allons nous intéresser à la notion de complexité : comment déterminer la vitesse d'un algorithme ? Si plusieurs *bonnes* solutions existent, alors il faut choisir la plus rapide. Mais&nbsp;sera&#8209;t&#8209;elle toujours la solution la plus rapide ?

Dans un deuxième temps, si vous le souhaitez, vous pouvez ouvrir la porte merveilleuse de la récursivité, à la manière des *Infinity Mirror Room* de Yayoi Kusama.

```{figure} media/Kusama.jpeg
---
alt: Infinity Mirror Room de Yayoi Kusama
width: 600px

```





## Objectifs

A la fin de ce chapitre, vous saurez ce qui fait qu'un algorithme est un bon algorithme et quels critères prendre en considération pour choisir le meilleur algorithme. Vous verrez également qu'il existe des problèmes relativement simples que l'on n'arrive toujours pas à résoudre.

<br>

* Pouvoir déterminer quelle est la meilleure solution pour un problème donné, en fonction de critères objectifs.  

* Comprendre pourquoi certains problème simples n'ont pas de solution exacte.

* [Optionnel] Créer des fonctions récursives, qui s'appellent elles&#8209;mêmes.  

